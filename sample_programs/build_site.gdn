import "./markdown.gdn"

// A list of all the files in `website_dir` that are templates.
//
// Returns absolute paths.
fun template_files(website_dir: Path): List<Path> {
  // TODO: a ? syntax.
  let dir_files = list_directory(website_dir).or_error()
  dir_files.filter(fun(p: Path) { p.p.ends_with(".tmpl.html") })
}

// A list of all the files in `website_dir` that have a .md extension.
fun markdown_files(website_dir: Path): List<Path> {
  let dir_files = list_directory(website_dir).or_error()
  dir_files.filter(fun(p: Path) { p.extension() == Some("md") })
}

// Convert "foo.tmpl.html" to "foo.html".
fun output_path(template_path: Path): Path {
  Path{ p: template_path.p.strip_suffix(".tmpl.html") ^ ".html"}
}

// Given a snippet of source code `src`, remove all the leading lines
// that are just comments.
fun drop_leading_comments(src: String): String {
  let lines = src.lines()

  let first_code_line = 0
  for (i, line) in lines.enumerate() {
    if line.starts_with("//") {
      continue
    }
    if line == "" {
      continue
    }

    first_code_line = i
    break
  }

  "\n".join(lines.slice(first_code_line, lines.len()))
}

// Look up the doc comment for `type_name`, render it to HTML and
// write it to `out_dir`.
fun write_type_page(type_name: String, out_dir: Path, base_tmpl_path: Path): Unit {
  match type_doc_comment(type_name) {
    Some(doc_comment) => {
      let (intro, rest) = match doc_comment.split_once("\n\n") {
        Some(tup) => tup,
        None => (doc_comment, ""),
      }

      let src = match type_source(type_name) {
        Some(src) => {
          "```\n" ^ (drop_leading_comments(src) ^ "\n```")
        }
        None => ""
      }

      let md_src = "".join(["# `", type_name, "` type\n\n" , intro, "\n\n", src])
      if rest != "" {
        md_src = md_src ^ ("\n\n" ^ rest)
      }

      let page_src = render_markdown(md_src)
      let dest_path = out_dir.join("type:" ^ (type_name ^ ".html"))
      write_website_page(base_tmpl_path, page_src, dest_path)
    }
    None => {}
  }
}

// Buld the entire garden website.
fun build_site(): Unit {
  let website_dir = source_dir_path().parent().parent().join("website")
  let out_dir = website_dir

  let tmpl_paths = template_files(website_dir)

  let base_tmpl_path = website_dir.join("template.html")

  for tmpl_path in tmpl_paths {
    let dest_path = output_path(tmpl_path)
    write_website_file(base_tmpl_path, tmpl_path, dest_path)
  }

  let seen_keyword_pages: List<String> = []

  for md_path in markdown_files(website_dir) {
    let file_name = match md_path.file_name() {
      Some(n) => n,
      None => continue,
    }

    match file_name.split_once(":") {
      Some((before, after)) => {
        if before == "keyword" {
          seen_keyword_pages = seen_keyword_pages.append(after.strip_suffix(".md"))
        }
      }
      None => {}
    }

    let dest_path = Path{ p: md_path.p.strip_suffix(".md") ^ ".html" }
    let page_src_md = md_path.read().or_error()
    let page_src = render_markdown(substitute_shorthand(page_src_md))
    write_website_page(base_tmpl_path, page_src, dest_path)
  }

  for keyword in keywords() {
    if seen_keyword_pages.contains(keyword).not() {
      println("Expected a page documenting: " ^ keyword)
    }
  }

  for type_name in built_in_types() {
    write_type_page(type_name, out_dir, base_tmpl_path)
  }
}

// Convert `["a", "b", "c"]` to `"a, b and c"`.
fun join_with_commas_and(items: List<String>): String {
  let last_item = match items.last() {
    Some(item) => item,
    None => return "",
  }

  let but_last = items.slice(0, -1)
  if but_last.is_empty() {
    return last_item
  }

  " and ".join([", ".join(but_last), last_item ^ "."])
}

// Replace all __FOO strings in markdown `src` with runtime values.
fun substitute_shorthand(src: String): String {
  let keyword_links = keywords().map(fun(keyword: String) {
    "".join(["[`", keyword, "`](./keyword:", keyword, ".html)"])
  })

  let keyword_links = join_with_commas_and(keyword_links)

  let type_links = built_in_types().map(fun(name: String) {
    "".join(["[`", name, "`](./type:", name, ".html)"])
  })

  let type_links = join_with_commas_and(type_links)

  src.replace("__KEYWORDS", keyword_links).replace("__BUILTIN_TYPES", type_links)
}

fun write_website_file(base_tmpl_path: Path, page_path: Path, dest_path: Path): Unit {
  let page_src = page_path.read().or_error()
  write_website_page(base_tmpl_path, page_src, dest_path)
}

// Wrap `page_src` in the base template and write to the file `dest_path`.
fun write_website_page(base_tmpl_path: Path, page_src: String, dest_path: Path): Unit {
  let base_tmpl_src = base_tmpl_path.read().or_error()
  let (header, footer) = match base_tmpl_src.split_once("MAIN_CONTENT") {
    Some(s) => s,
    None => ("", "")
  }

  let src = "".join([header.trim_right(), page_src, footer.trim_left()])
  write_file(src, dest_path).or_error()
}

{
  build_site()
}

fun main(_: List<String>) {
  build_site()
}

fun source_dir_path(): Path {
  source_directory().or_exception()
}
