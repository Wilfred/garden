enum MarkdownPart {
  Heading(String),
  Paragraph(String),
  Code(Snippet),
  Bullets(List<String>),
  ThematicBreak,
}

struct Snippet {
  language: String,
  content: String,
}

fun finish_section(in_bullets: Bool, current_section: List<String>): MarkdownPart {
  if in_bullets {
    Bullets(current_section)
  } else {
    Paragraph("\n".join(current_section))
  }
}

fun parse_markdown(src: String): List<MarkdownPart> {
  let parts: List<MarkdownPart> = []
  let current_section: List<String> = []

  let in_code_block = False
  let in_bullets = False

  for line in src.lines() {
    if (line == "") && current_section.is_empty() {
      continue
    }

    if line.starts_with("```") {
      current_section = current_section.append(line)

      if in_code_block {
        // Just finished the code block.
        let language = current_section.first().or_exception().strip_prefix("```")
        let content = "\n".join(current_section.slice(1, -1))

        let snippet = Snippet{
          language: language,
          content: content,
        }

        parts = parts.append(Code(snippet))
        current_section = []
        in_code_block = False
      } else {
        in_code_block = True
      }
    } else if in_code_block {
      current_section = current_section.append(line)
    } else if line == "---" {
      if current_section.is_non_empty() {
        parts = parts.append(finish_section(in_bullets, current_section))
      }

      parts = parts.append(ThematicBreak)
    } else if line.starts_with("#") {
      if current_section.is_non_empty() {
        parts = parts.append(finish_section(in_bullets, current_section))
        current_section = []
      }

      parts = parts.append(Heading(line))
    } else if line.starts_with("*") {
      if in_bullets {
        current_section = current_section.append(line)
      } else {
        if current_section.is_non_empty() {
          parts = parts.append(finish_section(in_bullets, current_section))
          current_section = []
        }

        in_bullets = True
        current_section = current_section.append(line)
      }

    } else if line == "" {
      parts = parts.append(Paragraph("\n".join(current_section)))
      current_section = []
    } else {
      current_section = current_section.append(line)
    }
  }

  if current_section.is_non_empty() {
    parts = parts.append(finish_section(in_bullets, current_section))
  }

  parts
}

fun render_markdown_header(src: String): String {
  let h_count = 0

  while src.starts_with("#") {
    h_count += 1
    src = src.strip_prefix("#")
  }

  let open_tag = "".join(["<h", string_repr(h_count), ">"])
  let close_tag = "".join(["</h", string_repr(h_count), ">"])

  "".join([open_tag, render_inline(src.strip_prefix(" ")), close_tag])
}

fun lex_with_ranges(s: String): List<(Int, Int, String)> {
  let items: List<(Int, Int, String)> = []

  let lexemes = lex(s)

  for i_idx_and_tok in lexemes.enumerate() {
    let (i, idx_and_tok) = i_idx_and_tok
    let (start_idx, tok) = idx_and_tok

    let end_idx = match lexemes.get(i + 1) {
      Some(next_idx_and_tok) => {
        let (next_idx, _) = next_idx_and_tok
        next_idx
      }
      None => s.len()
    }

    items = items.append((start_idx, end_idx, tok))
  }

  items
}

fun render_markdown_code(snippet: Snippet): String {
  if (snippet.language == "") {
    match check_snippet(snippet.content) {
      Ok(_) => {}
      Err(messages) => {
        println(snippet.content)
        for message in messages {
          println(message)
        }
      }
    }
  }

  let KEYWORDS = [
    "let", "fun", "enum", "struct", "export", "import", "if", "else", "while", "return", "test",
    "match", "break", "continue", "for", "in", "assert",
  ]

  let rendered_lines: List<String> = []

  for line in snippet.content.lines() {
    let rendered_line_parts: List<String> = []

    for i_and_tup in lex_with_ranges(line).enumerate() {
      let (i, tup) = i_and_tup
      let (start_idx, end_idx, tok) = tup

      if i == 0 {
        rendered_line_parts = rendered_line_parts.append(line.substring(0, start_idx))
      }

      let part = line.substring(start_idx, end_idx)

      let rendered_part = if tok.starts_with("//") {
        ("<span class=\"comment\">" ^ escape_angle_brackets(part)) ^ "</span>"
      } else if KEYWORDS.contains(tok) {
        let after_tok = part.substring(tok.len(), part.len())
        (((("<a href=\"./keyword:" ^ tok) ^ ".html\"><span class=\"keyword\">") ^ tok) ^ "</span></a>") ^ after_tok
      } else {
        escape_angle_brackets(part)
      }
      rendered_line_parts = rendered_line_parts.append(rendered_part)
    }
    rendered_lines = rendered_lines.append("".join(rendered_line_parts))
  }

  let inner_src = "\n".join(rendered_lines)
  ("<pre><code>" ^ inner_src) ^ "</code></pre>"
}

fun escape_angle_brackets(s: String): String {
  s.replace("<", "&lt;").replace(">", "&gt;")
}

fun render_inline(src: String): String {
  let parts: List<String> = []

  for piece in split_links(src) {
    if piece.starts_with("[") {
      parts = parts.append(render_link(piece))
    } else {
      parts = parts.append(render_inline_no_links(piece))
    }
  }

  "".join(parts)
}

fun render_inline_no_links(src: String): String {
  let parts: List<String> = []

  let s = src
  while True {
    match s.index_of("`") {
      Some(i) => {
        parts = parts.append(s.substring(0, i))

        s = s.substring(i, s.len())
        match s.substring(1, s.len()).index_of("`") {
          Some(j) => {
            let between = s.substring(1, j + 1)
            parts = parts.append("".join(["<code>", between, "</code>"]))
            s = s.substring(j + 2, s.len())
          }
          None => {
            parts = parts.append(s)
            break
          }
        }
      }
      None => {
        parts = parts.append(s)
        break
      }
    }
  }

  "".join(parts)
}

// Split `src` into a list of strings, where each string is either a
// link or a other text.
fun split_links(src: String): List<String> {
  let parts: List<String> = []

  let s = src
  while True {
    match s.index_of("[") {
      Some(i) => {

        match s.index_of(")") {
          Some(j) => {
            parts = parts.append(s.substring(0, i))
            parts = parts.append(s.substring(i, j + 1))
            s = s.substring(j + 1, s.len())
          }
          None => {
            parts = parts.append(s)
            break
          }
        }
      }
      None => {
        parts = parts.append(s)
        break
      }
    }
  }

  parts
}

fun render_link(src: String): String {
  assert(src.starts_with("["))

  match src.index_of("]") {
    Some(i) => {
      let link_text = src.substring(1, i)
      let link_url = src.substring(i + 2, src.len() - 1)
      "".join(["<a href=\"", link_url, "\">", render_inline_no_links(link_text), "</a>"])
    }
    None => src
  }
}

fun render_markdown_paragraph(src: String): String {
  "".join(["<p>", render_inline(src), "</p>"])
}

fun render_markdown_bullets(items: List<String>): String {
  let rendered_items = items.map(fun(item: String) {
    let rendered_item = render_inline(item.strip_prefix("*").trim_left())
    "".join(["<li>", rendered_item, "</li>"])
  })

  "".join(["<ul>\n", "\n".join(rendered_items), "\n</ul>"])
}

export fun render_markdown(src: String): String {
  let html_parts: List<String> = []

  for part in parse_markdown(src) {
    match part {
      Heading(heading) => {
        html_parts = html_parts.append(render_markdown_header(heading))
      }
      Paragraph(paragraph) => {
        html_parts = html_parts.append(render_markdown_paragraph(paragraph))
      }
      Code(code) => {
        html_parts = html_parts.append(render_markdown_code(code))
      }
      Bullets(items) => {
        html_parts = html_parts.append(render_markdown_bullets(items))
      }
      ThematicBreak => {
        html_parts = html_parts.append("<hr />")
      }
    }
  }

  "\n".join(html_parts)
}

test render_markdown_paragraph_newlines {
  assert(render_markdown("foo\nbar") == "<p>foo\nbar</p>")
}

test render_h1 {
  assert(render_markdown("# foo") == "<h1>foo</h1>")
}

test render_h2 {
  assert(render_markdown("## foo") == "<h2>foo</h2>")
}

test render_markdown_paragraph {
  assert(render_markdown("foo bar") == "<p>foo bar</p>")
}

test render_markdown_paragraph_after_heading {
  assert(render_markdown("# foo\n\nbar") == "<h1>foo</h1>\n<p>bar</p>")
}

test render_backtick {
  assert(render_markdown("`foo`") == "<p><code>foo</code></p>")
}

test render_backtick_in_heading {
  assert(render_markdown("# `foo`") == "<h1><code>foo</code></h1>")
}

test render_link {
  assert(render_markdown("[foo](example.com)") == "<p><a href=\"example.com\">foo</a></p>")
}

test render_backtick_in_link {
  assert(render_markdown("[`foo` bar](#)") == "<p><a href=\"#\"><code>foo</code> bar</a></p>")
}

test render_triple_backtick {
  assert(render_markdown("```\nfoo\nbar\n```") == "<pre><code>foo\nbar</code></pre>")
}

test render_triple_backtick_escape_html {
  assert(render_markdown("```\nfoo <bar>\n```") == "<pre><code>foo &lt;bar&gt;</code></pre>")
}

test render_triple_backtick_blank_line {
  assert(render_markdown("```\nfoo\n\nbar\n```") == "<pre><code>foo\n\nbar</code></pre>")
}

test render_triple_backtick_keyword {
  assert(render_markdown("```\nfun foo\n```") == "<pre><code><a href=\"./keyword:fun.html\"><span class=\"keyword\">fun</span></a> foo</code></pre>")
}

test render_triple_backtick_comment {
  assert(render_markdown("```\nfoo // bar\n```") == "<pre><code>foo <span class=\"comment\">// bar</span></code></pre>")
}

test render_asterisk {
  assert(render_markdown("* foo\n* bar") == "<ul>
<li>foo</li>
<li>bar</li>
</ul>")
}

test render_thematic_break {
  assert(render_markdown("---") == "<hr />")
}
