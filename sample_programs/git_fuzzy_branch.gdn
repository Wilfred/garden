#!/usr/bin/env -S garden run

fun lines(s) {
  let parts = [];

  let line_start = 0;
  let i = 0;
  while (i < string_length(s)) {
    let char = string_substring(s, i, i + 1);

    if (char == "\n") {
      parts = list_append(parts, string_substring(s, line_start, i));
      line_start = i + 1;
    }

    i = i + 1;
  }

  // Append last line if it wasn't terminated with a newline.
  if (line_start != string_length(s)) {
    parts = list_append(parts,
      string_substring(s, line_start, string_length(s)));
  }

  parts;
}

fun (self: List) filter(f) {
  let result = [];

  let i = 0;
  while (i < list_length(self)) {
    let item = list_get(self, i);

    if (f(item)) {
      result = list_append(result, item);
    }

    // todo: handle parse errors better if this semicolon is missing.
    i = i + 1;
  }
  result;
}

fun (self: String) contains(needle) {
  if (string_length(needle) > string_length(self)) {
    return false;
  }

  // TODO: better parse error if this last parenthesis is missing.
  // dbg(string_length(haystack) - string_length(needle));

  let i = 0;
  while (i <= (string_length(self) - string_length(needle))) {
    let section = string_substring(self, i, i + string_length(needle));
    if (section == needle) {
      return true;
    }

    i = i + 1;
  }

  false;
}

fun (self: List) is_empty() {
  list_length(self) == 0;
}

fun (self: String) join(items) {
  if (items.is_empty()) {
    return "";
  }
  if (list_length(items) == 1) {
    return list_get(items, 0);
  }

  let res = list_get(items, 0);
  let i = 1;
  while (i < list_length(items)) {
    res = string_concat(res, self);
    res = string_concat(res, list_get(items, i));
    i = i + 1;
  }
  res;
}

fun in_git_repo() {
  let git_dir_path = string_concat(working_directory(), "/.git");
  path_exists(git_dir_path);
}

fun main(args) {
  if (list_length(args) != 1) {
    print("Usage: git_fuzzy_branch <name substring>");
    // TODO: support void values.
    return false;
  }
  let needle = list_get(args, 0);

  if (in_git_repo()) {
    // TODO: One branch matches exactly?
    let all_branches = lines(shell("git", ["for-each-ref", "--format=%(refname:short)", "refs/heads/"]));
    let branches = all_branches.filter(fun(name) { name.contains(needle); });

    if (branches.is_empty()) {
      print(string_concat("No branches found maching: ", needle));
    } else if (list_length(branches) == 1) {
      let branch_name = list_get(branches, 0);
      print(string_concat("Checking out: ", branch_name));
      print(shell("git", ["checkout", branch_name]));
    } else {
      let formatted_branches = ", ".join(branches);
      let msg = "".join(["Found ", int_to_string(list_length(branches)), " branches: ", formatted_branches]);
      print(msg);
    }
  } else {
    print("Not in a git repository.");
  }
}
