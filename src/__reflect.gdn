// Only used in tests.
import "__prelude.gdn" as prelude
import "__fs.gdn" as fs

// Check the syntax of `src`.
public fun check_snippet(src: String): Result<Unit, List<String>> {
  __BUILTIN_IMPLEMENTATION
}

test check_snippet_good {
  match check_snippet("fun foo() {}") {
    Ok(_) => {}
    Err(_) => {
      assert(False)
    }
  }
}

test check_snippet_bad_syntax {
  match check_snippet("fun foo(") {
    Ok(_) => {
      assert(False)
    }
    Err(_) => {}
  }
}

test check_snippet_bad_name {
  match check_snippet("fun foo() { bar() }") {
    Ok(_) => {
      assert(False)
    }
    Err(_) => {}
  }
}

// Split `src` into individual lexed tokens, along with their offsets
// in the original string.
public fun lex(src: String): List<(Int, String)> {
  __BUILTIN_IMPLEMENTATION
}

test lex {
  // Basic case.
  assert(lex("a 123 \"b c d\"") == [(0, "a"), (2, "123"), (6, "\"b c d\"")])

  // We should include preceding comments on tokens.
  assert(lex("a // b\n c") == [(0, "a"), (2, "// b\n"), (8, "c")])

  // We should include comments that have no token afterwards.
  assert(lex("a // b\n") == [(0, "a"), (2, "// b\n")])

  // Comments should not require a newline at EOF.
  assert(lex("a // b") == [(0, "a"), (2, "// b")])
}

// Get the doc comment for `fun_name` in the namespace `ns`. The
// string does not include the leading `//` comment.
public fun doc_comment(ns: Namespace, fun_name: String): Option<String> {
  __BUILTIN_IMPLEMENTATION
}

test doc_comment {
  match doc_comment(fs, "write_file") {
    Some(_) => {}
    None => { assert(False) }
  }
}

// Get the doc comment for type `type_name`.
public fun doc_comment_for_type(type_name: String): Option<String> {
  __BUILTIN_IMPLEMENTATION
}

test doc_comment_for_type {
  match doc_comment_for_type("Unit") {
    Some(_) => {}
    None => { assert(False) }
  }

  match doc_comment_for_type("NoSuchTypeExists") {
    Some(_) => { assert(False) }
    None => {}
  }
}

// Get the doc comment for the method `method_name` on `type_name`.
public fun doc_comment_for_method(type_name: String, method_name: String): Option<String> {
  __BUILTIN_IMPLEMENTATION
}

test doc_comment_for_method {
  match doc_comment_for_method("List", "len") {
    Some(_) => {}
    None => { assert(False) }
  }
}

// A list of all the type names in the prelude, `String`, `Option` and
// so on. The list is sorted alphabetically.
public fun prelude_types(): List<String> {
  __BUILTIN_IMPLEMENTATION
}

test prelude_types {
  assert(prelude_types().contains("Unit"))
  assert(prelude_types().contains("Fun"))
  assert(prelude_types().contains("String"))

  assert(prelude_types().first() == Some("Bool"))
}

// All the keywords in Garden. Variables cannot use these as names.
public fun keywords(): List<String> {
  __BUILTIN_IMPLEMENTATION
}

test keywords {
  assert(keywords().contains("if"))
}

// All the operators in Garden.
public fun operators(): List<String> {
  // Missing: ["/", "%"]
  ["+", "+=", "-", "-=", "*", "**", "==", "!=", "=", "^", ">", "<", "%"]
}

// Get the source code for the type definition of `name`.
public fun source_for_type(name: String): Option<String> {
  __BUILTIN_IMPLEMENTATION
}

test source_for_type {
  match source_for_type("Unit") {
    Some(source) => {
      assert(source.starts_with("// "))
    }
    None => {
      assert(False)
    }
  }
}

// Get the source code for the function definition of `name`.
public fun source_for_fun(ns: Namespace, name: String): Option<String> {
  __BUILTIN_IMPLEMENTATION
}

test source_for_fun {
  // Built-in function.
  match source_for_fun(prelude, "throw") {
    Some(source) => {
      assert(source.starts_with("// "))
    }
    None => {
      assert(False)
    }
  }

  // Function implemented in Garden.
  match source_for_fun(prelude, "todo") {
    Some(source) => {
      assert(source.starts_with("// "))
    }
    None => {
      assert(False)
    }
  }
}

// Get the source code for the function definition of `name`.
public fun source_for_method(type_name: String, method_name): Option<String> {
  __BUILTIN_IMPLEMENTATION
}

test source_for_method {
  match source_for_method("String", "len") {
    Some(source) => {
      assert(source.starts_with("// "))
    }
    None => {
      assert(False)
    }
  }
}

// All the `external` functions in `ns`.
public fun namespace_functions(ns: Namespace): List<String> {
  // This is deliberately not a method on Namespace, so code
  // completion isn't confusing.
  __BUILTIN_IMPLEMENTATION
}

test namespace_functions {
  let items = namespace_functions(fs)
  assert(items.contains("list_directory"))
}

// Get all the methods defined on a given type.
public fun methods_for_type(type_name: String): List<String> {
  __BUILTIN_IMPLEMENTATION
}

test methods_for_type {
  let string_methods = methods_for_type("String")
  assert(string_methods.contains("len"))
}
