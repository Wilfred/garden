// Basic types.

// The boolean type. This type represents when something is true or
// false, such as predicates.
enum Bool {
  True,
  False,
}

export fun (this: Bool) not(): Bool {
  match this {
    True => False,
    False => True,
  }
}

test not {
  assert(True.not() == False)
  assert(False.not() == True)
}

// The unit type. Use this when your function doesn't have any useful
// value to return, such as side-effecting functions.
enum Unit {
  Unit
}

// The option type. Use this when you might have a value, but might
// not.
enum Option<T> {
  Some(T),
  None,
}

/// Return True if this value is `Some`.
export fun (this: Option<T>) is_some<T>(): Bool {
  match this {
    Some(_) => True,
    None => False,
  }
}

/// Return True if this value is `None`.
export fun (this: Option<T>) is_none<T>(): Bool {
  match this {
    Some(_) => False,
    None => True,
  }
}

// `Result` represents a value that succeeded, with `Ok(...)`, or
// failed, with `Err(...)`.
enum Result<T, E> {
  Ok(T),
  Err(E),
}

// Write an arbitrary value to stdout, along with debugging metadata.
//
// Returns the input, so you can use `dbg` in larger expressions
// `foo(dbg(bar()))`.
//
// ```
// dbg([1, 2])
// ```
export fun dbg<T>(value: T): T {
  println(string_repr(value))
  value
}

// Raise an error.
//
// You can use this function for code that you haven't implemented
// yet.
export fun todo(): NoValue {
  error("Not yet implemented")
}

// If this value is `Ok`, unwrap it, otherwise error.
export fun (this: Result<T, E>) or_error<T, E>(): T {
  match this {
    Ok(v) => v
    Err(e) => error(" ".join(["Called .unwrap() on an Err.", string_repr(e)]))
  }
}

test or_error {
  assert(Ok("foo").or_error() == "foo")
}

enum NoValue {}

// String methods.

// Does this string start with `s`?
export fun (this: String) starts_with(s: String): Bool {
  if s.len() > this.len() {
    return False
  }

  this.substring(0, s.len()) == s
}

test starts_with {
  assert("abc".starts_with("ab") == True)
  assert("abc".starts_with("") == True)

  assert("abc".starts_with("x") == False)
  assert("abc".starts_with("b") == False)
  assert("abc".starts_with("abcaa") == False)
}

// Does this string end with `s`?
export fun (this: String) ends_with(s: String): Bool {
  if s.len() > this.len() {
    return False
  }

  this.substring(this.len() - s.len(), this.len()) == s
}

test ends_with {
  assert("abc".ends_with("bc") == True)
  assert("abc".ends_with("") == True)

  assert("abc".ends_with("x") == False)
  assert("abc".ends_with("b") == False)
  assert("abc".ends_with("aabc") == False)
}

// Split this string into a list of lines.
export fun (this: String) lines(): List<String> {
  let parts: List<String> = []

  let line_start = 0
  let i = 0
  while i < this.len() {
    let char = this.substring(i, i + 1)

    if char == "\n" {
      parts = parts.append(this.substring(line_start, i))
      line_start = i + 1
    }

    i += 1
  }

  // Append last line if it wasn't terminated with a newline.
  if line_start != this.len() {
    parts = parts.append(this.substring(line_start, this.len()))
  }

  parts
}

test lines {
  assert("".lines() == [])
  assert("a".lines() == ["a"])
  assert("a\nb".lines() == ["a", "b"])
  assert("a\nb\n".lines() == ["a", "b"])
}

// Split this string on the first occurrence of `needle`, and return
// the text before and after `needle`.
//
// ```
// "abcd".split_once("b") // Some(["a", "cd"])
// ```
export fun (this: String) split_once(needle: String): Option<(String, String)> {
  let i = 0
  while (i + needle.len()) <= this.len() {
    let substring = this.substring(i, i + needle.len())
    if substring == needle {
      return Some((
        this.substring(0, i),
        this.substring(i + needle.len(), this.len()),
      ))
    }

    i += 1
  }

  return None
}

test split_once {
  assert("abc".split_once("x") == None)

  assert("abc".split_once("b") == Some(("a", "c")))
  assert("abc".split_once("c") == Some(("ab", "")))
  assert("abcbe".split_once("b") == Some(("a", "cbe")))
}

test string_index_of {
  assert("abc".index_of("x") == None)

  assert("abc".index_of("a") == Some(0))
  assert("abca".index_of("a") == Some(0))

  assert("abc".index_of("c") == Some(2))
}

// Join `items` (a list of strings) with this string as a separator.
//
// ```
// ":".join(["a", "b", "c"]) // "a:b:c"
// ```
export fun (this: String) join(items: List<String>): String {
  if items.is_empty() {
    return ""
  }
  if items.len() == 1 {
    return items.get(0)
  }

  let res = items.get(0)
  let i = 1
  while i < items.len() {
    res = res.append(this)
    res = res.append(items.get(i))
    i += 1
  }
  res
}

test join {
  assert(" ".join(["x"]) == "x")

  // TODO: should .join() exist on String or on List?
  assert(" ".join(["x", "y"]) == "x y")
}

// Does this string contain `substring`?
export fun (this: String) contains(substring: String): Bool {
  if substring.len() > this.len() {
    return False
  }

  // TODO: better parse error if this last parenthesis is missing.
  // dbg(string_length(haystack) - string_length(substring))

  let i = 0
  while i <= (this.len() - substring.len()) {
    let section = this.substring(i, i + substring.len())
    if section == substring {
      return True
    }

    i += 1
  }

  False
}

export fun (this: String) trim_left(): String {
  let i = 0
  while i < this.len() {
    let char = this.substring(i, i + 1)
    if char != " " {
      break
    }

    i += 1
  }

  this.substring(i, this.len())
}

test trim_left {
  assert("a".trim_left() == "a")
  assert("a b".trim_left() == "a b")
  assert("  a".trim_left() == "a")
  assert("a ".trim_left() == "a ")
}

export fun (this: String) trim_right(): String {
  let i = this.len() - 1
  while i >= 0 {
    let char = this.substring(i, i + 1)
    if char != " " {
      break
    }

    i -= 1
  }

  this.substring(0, i + 1)
}

test trim_right {
  assert("a".trim_right() == "a")
  assert("a b".trim_right() == "a b")
  assert(" a".trim_right() == " a")
  assert("a  ".trim_right() == "a")
}

// Returns this string without the suffix specified. If this string
// does not end with the suffix, return the string unchanged.
//
// ```
// "foo".strip_suffix("o") // "fo"
// "bar".strip_suffix("o") // "bar"
// ```
export fun (this: String) strip_suffix(suffix: String): String {
  if this.ends_with(suffix) {
    return this.substring(0, this.len() - suffix.len())
  }

  this
}

test strip_suffix {
  assert("abcdef".strip_suffix("ef") == "abcd")
  assert("abcdef".strip_suffix("xyz") == "abcdef")
}

// Returns this string without the prefix specified. If this string
// does not start with the prefix, return the string unchanged.
//
// ```
// "foo".strip_prefix("f") // "oo"
// "bar".strip_prefix("f") // "bar"
// "ffoo".strip_prefix("f") // "foo"
// ```
export fun (this: String) strip_prefix(prefix: String): String {
  if this.starts_with(prefix) {
    // return this.substring(prefix.len(), this.len(), 1)
    return this.substring(prefix.len(), this.len())
  }

  this
}

test strip_prefix {
  assert("abcdef".strip_prefix("ab") == "cdef")
  assert("abcdef".strip_prefix("xyz") == "abcdef")
}

// Split this string on occurrences of `needle`.
//
// ```
// "a,b".split(",") // ["a", "b"]
// "ab".split(",") // ["ab"]
// "a,,b,".split(",") // ["a", "", "b", ""]
// ```
export fun (this: String) split(needle: String): List<String> {
  let s = this

  let parts: List<String> = []
  while s != "" {
    match s.index_of(needle) {
      Some(i) => {
        parts = parts.append(s.substring(0, i))
        s = s.substring(i + needle.len(), s.len())
      }
      None => {
        parts = parts.append(s)
        break
      }
    }

  }


  parts
}

test split {
  assert("ab".split(",") == ["ab"])
  assert("a,b".split(",") == ["a", "b"])
  assert("a,,b".split(",") == ["a", "", "b"])
}

export fun (this: String) chars(): List<String> {
  let cs: List<String> = []

  let i = 0
  while i < this.len() {
    cs = cs.append(this.substring(i, i + 1))
    i += 1
  }

  cs
}

test string_chars {
  assert("abc".chars() == ["a", "b", "c"])
}

// List methods.

// Get the first item in this list, if the list is not empty.
export fun (this: List<T>) first<T>(): Option<T> {
  if this.is_empty() {
    None
  } else {
    Some(this.get(0))
  }
}

test first {
  assert([].first() == None)
  assert([123].first() == Some(123))
}

// Get the last item in this list, if the list is not empty.
export fun (this: List<T>) last<T>(): Option<T> {
  if this.is_empty() {
    None
  } else {
    Some(this.get(this.len() - 1))
  }
}

test last {
  assert([].last() == None)
  assert([123].last() == Some(123))
}

// Return a copy of this list with the items where `f(item)` returns
// True.
export fun (this: List<T>) filter<T>(f: Fun<(T), Bool>): List<T> {
  let result: List<T> = []

  for item in this {
    if f(item) {
      result = result.append(item)
    }
  }

  result
}

test filter {
  assert([1, 2].filter(fun(_) { True }) == [1, 2])
}

// Is this list empty?
export fun (this: List<T>) is_empty<T>(): Bool {
  this.len() == 0
}

test is_empty {
  assert([].is_empty())
  assert([1].is_empty().not())
}

// Is this list non-empty?
export fun (this: List<T>) is_non_empty<T>(): Bool {
  this.len() != 0
}

test is_non_empty {
  assert([].is_non_empty().not())
  assert([1].is_non_empty())
}

// Does this list contain `item`?
export fun (this: List<T>) contains<T>(item: T): Bool {
  for this_item in this {
    if this_item == item {
      return True
    }
  }

  False
}

test contains {
  assert([10, 11].contains(10) == True)
}

// Call `f` on every item in this list, and return a list of the
// results.
//
// ```
// [1, 2].map(fun(x) { x + 1 }) // [2, 3]
// ```
export fun (this: List<T>) map<T, U>(f: Fun<(T), U>): List<U> {
  let items: List<U> = []
  for item in this {
    items = items.append(f(item))
  }

  items
}

test list_map {
  let incremented = [1, 2, 3].map(fun(x: Int) { x + 1 })
  assert(incremented == [2, 3, 4])
}

// Return a new list consisting of the items from index i (inclusive)
// to index j (exclusive). If `j` is negative, count backwards from
// the end.
//
// [10, 11, 12].slice(0, 2) // [10, 11]
// [10, 11, 12].slice(1, -1) // [11, 12]
export fun (this: List<T>) slice<T>(i: Int, j: Int): List<T> {
  if (j < 0) {
    j = this.len() + j
  }

  let items: List<T> = []

  let index = 0
  for item in this {
    if (index >= i) && (index < j) {
      items = items.append(item)
    }

    index += 1
  }

  items
}

test list_slice {
  assert([10, 11, 12].slice(0, 1) == [10])
  assert([10, 11, 12].slice(1, 2) == [11])
  assert([10, 11, 12].slice(0, 2) == [10, 11])

  assert([10, 11, 12].slice(0, -1) == [10, 11])
}

// Option methods.

// If this value is `Some(value)`, unwrap it, otherwise throw an exception.
export fun (this: Option<T>) or_exception<T>(): T {
  match this {
    Some(v) => v,
    None => error("Called or_exception on a `None` value.")
  }
}

test option_or_exception {
  assert(Some(123).or_exception() == 123)
}

// If this value is `Some(x)`, return `x`, otherwise return `value`.
//
// ```
// Some(1).or_value(5) // 1
// None.or_value(5) // 5
// ```
export fun (this: Option<T>) or_value<T>(value: T): T {
  match this {
    Some(v) => v,
    None => value
  }
}

test option_or_value {
  assert(Some(1).or_value(5) == 1)

  let n: Option<Int> = None
  assert(n.or_value(5) == 5)
}

// A filesytsem path.
struct Path {
  p: String,
}

// The parent directory of this path.
export fun (this: Path) parent(): Path {
  let parts = this.p.split("/")
  let parent_s = "/".join(parts.slice(0, -1))
  Path{ p: parent_s }
}

// Append `component` to this path.
export fun (this: Path) join(component: String): Path {
  Path{ p: "/".join([this.p, component]) }
}

// The extension of this path, if this path is a file whose name
// includes a ".".
export fun (this: Path) extension(): Option<String> {
  let name = match this.file_name() {
    Some(name) => name
    None => return None
  }

  name.split(".").last()
}

// The file name of this path, if this path is a file (i.e. not a
// directory).
export fun (this: Path) file_name(): Option<String> {
  this.p.split("/").last()
}
