import "__prelude.gdn" as prelude
import "__reflect.gdn" as reflect

import "./log.gdn" as log

enum MarkdownPart {
  Heading(String),
  Paragraph(String),
  CodeBlock(Snippet),
  Bullets(List<String>),
  ThematicBreak,
}

struct Snippet {
  labels: List<String>,
  title: Option<String>,
  content: String,
}

fun finish_section(in_bullets: Bool, current_section: List<String>): MarkdownPart {
  if in_bullets {
    Bullets(current_section)
  } else {
    Paragraph("\n".join(current_section))
  }
}

// Parse the text after the ``` on markdown blocks.
//
// These labels are generally space-separated, but may contain double quotes.
//
// For example:
//
// label1 label2 foo:"label three"
fun parse_labels(src: String): List<String> {
  let labels: List<String> = []

  let s = src
  while s != "" {
    let word = ""
    match s.index_of(" ") {
      Some(i) => {
        word = s.substring(0, i)
        s = s.substring(i + 1, s.len())
      }
      None => {
        labels = labels.append(s)
        break
      }
    }

    if word.contains("\"") {
      match s.index_of("\"") {
        Some(i) => {
          word = word ^ " " ^ s.substring(0, i + 1)
          s = s.substring(i + 1, s.len())
        }
        None => {}
      }
    }

    labels = labels.append(word)
  }

  labels
}

fun parse_labels_and_title(src: String): (Option<String>, List<String>) {
  let all_labels = parse_labels(src)

  let labels: List<String> = []
  let title: Option<String> = None
  for label in all_labels {
    if label.starts_with("title:") {
      title = Some(label.strip_prefix("title:").strip_prefix("\"").strip_suffix("\""))
    } else {
      labels = labels.append(label)
    }
  }

  (title, labels)
}

fun parse_markdown(src: String): List<MarkdownPart> {
  let parts: List<MarkdownPart> = []
  let current_section: List<String> = []

  let in_code_block = False
  let in_bullets = False

  for line in src.lines() {
    if (line == "") && current_section.is_empty() {
      continue
    }

    if line.starts_with("```") {
      current_section = current_section.append(line)

      if in_code_block {
        // Just finished the code block.
        let label_str = current_section.first().or_throw().strip_prefix("```")
        let (title, labels) = parse_labels_and_title(label_str)

        let content = "\n".join(current_section.slice(1, -1))

        let snippet = Snippet{
          labels: labels,
          title: title,
          content: content,
        }

        parts = parts.append(CodeBlock(snippet))
        current_section = []
        in_code_block = False
      } else {
        in_code_block = True
      }
    } else if in_code_block {
      current_section = current_section.append(line)
    } else if ((line == "---") || (line == "***")) || (line == "___") {
      if current_section.is_non_empty() {
        parts = parts.append(finish_section(in_bullets, current_section))
        in_bullets = False
      }

      parts = parts.append(ThematicBreak)
    } else if line.starts_with("#") {
      if current_section.is_non_empty() {
        parts = parts.append(finish_section(in_bullets, current_section))
        in_bullets = False

        current_section = []
      }

      parts = parts.append(Heading(line))
    } else if line.starts_with("* ") {
      if in_bullets {
        current_section = current_section.append(line)
      } else {
        if current_section.is_non_empty() {
          parts = parts.append(finish_section(in_bullets, current_section))
          current_section = []
        }

        in_bullets = True
        current_section = current_section.append(line)
      }

    } else if line == "" {
      parts = parts.append(finish_section(in_bullets, current_section))
      in_bullets = False

      current_section = []
    } else {
      current_section = current_section.append(line)
    }
  }

  if current_section.is_non_empty() {
    parts = parts.append(finish_section(in_bullets, current_section))
  }

  parts
}

fun render_markdown_header(src: String): String {
  let h_count = 0

  let content = src
  while content.starts_with("#") {
    h_count += 1
    content = content.strip_prefix("#")
  }

  if (h_count > 6) || content.starts_with(" ").not() {
    return "<p>" ^ src ^ "</p>"
  }

  let open_tag = "<h" ^ string_repr(h_count) ^ ">"
  let close_tag = "</h" ^ string_repr(h_count) ^ ">"

  open_tag ^ render_inline(content.trim()) ^ close_tag
}

// We want to find " < ", which requires trailing whitespace on the
// previous lexeme as well as the < lexeme.
fun lex_with_ranges(s: String): List<(Int, Int, String)> {
  let items: List<(Int, Int, String)> = []

  let lexemes = reflect::lex(s)

  for (i, idx_and_tok) in lexemes.enumerate() {
    let (start_idx, tok) = idx_and_tok

    let end_idx = match lexemes.get(i + 1) {
      Some((next_idx, _)) => {
        next_idx
      }
      None => s.len()
    }

    items = items.append((start_idx, end_idx, tok))
  }

  items
}

fun render_markdown_code(snippet: Snippet): String {
  let inner = if snippet.labels.is_empty() || snippet.labels.contains("garden") {
    render_markdown_garden_code(snippet)
  } else {
    "<code>" ^ escape_angle_brackets(snippet.content) ^ "</code>"
  }

  match snippet.title {
    Some(title) => {
      inner = "<span class=\"code-title\">" ^ title ^ "</span>" ^ inner
    }
    None => {}
  }

  "<pre>" ^ inner ^ "</pre>"
}

fun check_source(src: String): Unit {
  match reflect::check_snippet(src) {
    Ok(_) => {}
    Err(messages) => {
      log::warn("Found an error when checking: " ^ src)
      for message in messages {
        log::info("  " ^ message)
      }
    }
  }
}

fun render_markdown_garden_code(snippet: Snippet): String {
  if snippet.labels.contains("nocheck").not() {
    check_source(snippet.content)

    // Check that the expected values comments type check too.
    for line in snippet.content.lines() {
      match line.split_once("//->") {
        Some((_before, after)) => {
          check_source(after)
        }
        None => {}
      }
    }
  }

  let keywords = reflect::keywords()
  let operators = reflect::operators()
  let prelude_funs = reflect::namespace_functions(prelude)
  let rendered_lines: List<String> = []

  for line in snippet.content.lines() {
    let rendered_line_parts: List<String> = []

    let prev_had_trailing_ws = False
    for (i, tup) in lex_with_ranges(line).enumerate() {
      let (start_idx, end_idx, tok) = tup
      let has_trailing_ws = start_idx + tok.len() < end_idx

      if i == 0 {
        rendered_line_parts = rendered_line_parts.append(line.substring(0, start_idx))
      }

      let part = line.substring(start_idx, end_idx)

      let rendered_part = if tok.starts_with("//") {
        "<span class=\"comment\">" ^ escape_angle_brackets(part) ^ "</span>"
      } else if tok.starts_with("\"") {
        "<span class=\"string\">" ^ escape_angle_brackets(part) ^ "</span>"
      } else if keywords.contains(tok) {
        let after_tok = part.substring(tok.len(), part.len())
        "<a class=\"keyword\" href=\"/keyword:" ^ tok ^ ".html\">" ^ tok ^ "</a>" ^ after_tok
      } else if operators.contains(tok) {
        if prev_had_trailing_ws && has_trailing_ws {
          // We want to distinguish `List<Int>`, where there isn't an
          // operator, from `1 < 2` where there is an operator.
          //
          // This is an imperfect heuristic because we're only using
          // the lexer. It would be better to expose the full parser
          // to userland Garden code.
          let after_tok = part.substring(tok.len(), part.len())
          "<a class=\"operator\" href=\"/operator:" ^ tok ^ ".html\">" ^ escape_angle_brackets(tok) ^ "</a>" ^ after_tok
        } else {
          escape_angle_brackets(part)
        }
      } else if prelude_funs.contains(tok) {
        let after_tok = part.substring(tok.len(), part.len())
        "<a href=\"/fun:__prelude.gdn::" ^ tok ^ ".html\">" ^ tok ^ "</a>" ^ after_tok
      } else if looks_like_type(tok) {
        let after_tok = part.substring(tok.len(), part.len())
        if reflect::prelude_types().contains(tok) {
          "<a class=\"type\" href=\"/type:" ^ tok ^ ".html\">" ^ tok ^ "</a>" ^ after_tok
        } else {
          "<span class=\"type\">" ^ tok ^ "</span>" ^ after_tok
        }
      } else {
        escape_angle_brackets(part)
      }
      rendered_line_parts = rendered_line_parts.append(rendered_part)

      prev_had_trailing_ws = has_trailing_ws
    }

    rendered_lines = rendered_lines.append("".join(rendered_line_parts))
  }

  let inner_src = "\n".join(rendered_lines)
  "<code>" ^ inner_src ^ "</code>"
}

fun escape_angle_brackets(s: String): String {
  s.replace("<", "&lt;").replace(">", "&gt;")
}

fun render_inline(src: String): String {
  let parts: List<String> = []

  for piece in split_inline_parts(src) {
    if piece.starts_with("[") {
      parts = parts.append(render_link(piece))
    } else if piece.starts_with("![") {
      parts = parts.append(render_image(piece))
    } else if piece.starts_with("<") {
      parts = parts.append(piece)
    } else if piece.starts_with("**") && piece.ends_with("**") {
      parts = parts.append(render_strong(piece))
    } else if piece.starts_with("*") && piece.ends_with("*") {
      parts = parts.append(render_emphasis(piece))
    } else if piece.starts_with("`") {
      parts = parts.append(render_inline_code(piece))
    } else {
      parts = parts.append(escape_angle_brackets(piece))
    }
  }

  "".join(parts)
}

fun render_inline_backticks(src: String): String {
  let parts: List<String> = []

  let s = src
  while True {
    match s.split_once("`") {
      Some((before_backtick, after_backtick)) => {
        parts = parts.append(escape_angle_brackets(before_backtick))

        match after_backtick.split_once("`") {
          Some((between_backticks, after_closing_backtick)) => {
            parts = parts.append("<code>" ^ escape_angle_brackets(between_backticks) ^ "</code>")
            s = after_closing_backtick
          }
          None => {
            parts = parts.append(escape_angle_brackets(s))
            break
          }
        }
      }
      None => {
        parts = parts.append(escape_angle_brackets(s))
        break
      }
    }
  }

  "".join(parts)
}

// Split `src` into a list of strings, where each string is either a
// link, image, HTML, inline code or a piece of plain text.
fun split_inline_parts(src: String): List<String> {
  let parts: List<String> = []

  let s = src
  while True {
    match first_idx(s, ["[", "![", "<", "*", "`"]) {
      Some(idx) => {
        let before_bracket = s.substring(0, idx)
        let after_bracket = s.substring(idx, s.len())

        if after_bracket.starts_with("`") {
          // `inline code` syntax.
          match split_on_terminator(after_bracket.substring(1, after_bracket.len()), "`") {
            Some((part, after_part)) => {
              parts = parts.append(before_bracket)
              parts = parts.append("`" ^ part)
              s = after_part
            }
            None => {
              parts = parts.append(s)
              break
            }
          }
        } else if after_bracket.starts_with("<") {
          // This is an HTML tag.
          match split_on_terminator(after_bracket, ">") {
            Some((part, after_part)) => {
              parts = parts.append(before_bracket)
              parts = parts.append(part)
              s = after_part
            }
            None => {
              parts = parts.append(s)
              break
            }
          }
        } else if after_bracket.starts_with("[") || after_bracket.starts_with("!") {
          // This is a link or image.
          match split_markdown_link(after_bracket) {
            Some((part, after_part)) => {
              parts = parts.append(before_bracket)
              parts = parts.append(part)
              s = after_part
            }
            None => {
              // We saw malformed syntax, e.g. an unfinished link `[foo](bar`.
              // Treat it as simple text.
              parts = parts.append(s)
              break
            }
          }
        } else if after_bracket.starts_with("**") {
          // A **strong** substring. For simplicity, we assume this
          // does not nest with links. This doesn't match the
          // commonmark spec, but it covers the common cases.
          match split_on_terminator(after_bracket.substring(2, after_bracket.len()), "**") {
            Some((part, after_part)) => {
              parts = parts.append(before_bracket)
              parts = parts.append("**" ^ part)
              s = after_part
            }
            None => {
              parts = parts.append(s)
              break
            }
          }
        } else if after_bracket.starts_with("*") {
          // An *emphasis* substring. As with **strong**, this is
          // simplistic implementation that doesn't cover all cases in
          // the commonmark spec.
          match split_on_terminator(after_bracket.substring(1, after_bracket.len()), "*") {
            Some((part, after_part)) => {
              parts = parts.append(before_bracket)
              parts = parts.append("*" ^ part)
              s = after_part
            }
            None => {
              parts = parts.append(s)
              break
            }
          }
        }
      }
      None => {
        // No more delimiters in `s`.
        parts = parts.append(s)
        break
      }
    }
  }

  parts
}

// If `s` contains `terminator`, return the string up to the
// terminator (inclusive), and the string beyond it.
fun split_on_terminator(s: String, terminator: String): Option<(String, String)> {
  match s.split_once(terminator) {
    Some((before, after)) => {
      Some((before ^ terminator, after))
    }
    None => None,
  }
}

// Split a markdown link or image from the start of `s`.
//
// ```
// split_markdown_link("[link text](url) rest") // Some(("[link text](url)", " rest"))
// ```
fun split_markdown_link(s: String): Option<(String, String)> {
  if s.starts_with("[").not() && s.starts_with("![").not() {
    return None
  }

  // Find the closing ] of the link text
  let close_bracket_idx = match s.index_of("](") {
    Some(i) => i
    None => return None
  }

  // Find the matching ) for the URL part
  match s.substring(close_bracket_idx, s.len()).index_of(")") {
    Some(url_close_idx) => {
      let link_end = close_bracket_idx + url_close_idx + 1

      let link_part = s.substring(0, link_end)
      let remaining = s.substring(link_end, s.len())
      Some((link_part, remaining))
    }
    None => None
  }
}

test split_on_terminator {
  assert(split_on_terminator("abc", "b") == Some(("ab", "c")))
}

test split_markdown_link {
  assert(split_markdown_link("[foo](bar.html)") == Some(("[foo](bar.html)", "")))
  assert(split_markdown_link("[foo (bar)](baz.html)") == Some(("[foo (bar)](baz.html)", "")))
  assert(split_markdown_link("[foo](bar.html) remaining") == Some(("[foo](bar.html)", " remaining")))
  assert(split_markdown_link("not a link") == None)
  assert(split_markdown_link("[unclosed") == None)
}

// If `s` contains any of the items in `substrings`, return the index
// of the first match.
fun first_idx(s: String, substrings: List<String>): Option<Int> {
  let indices: List<Int> = []
  for char in substrings {
    match s.index_of(char) {
      Some(idx) => {
        indices = indices.append(idx)
      }
      None => {}
    }
  }

  min(indices)
}

test first_idx {
  assert(first_idx("abc", []) == None)
  assert(first_idx("abc", ["x"]) == None)
  assert(first_idx("abc", ["c", "b"]) == Some(1))
}

fun min(items: List<Int>): Option<Int> {
  let smallest = match items.first() {
    Some(item) => item,
    None => { return None }
  }

  for item in items {
    if item < smallest {
      smallest = item
    }
  }

  Some(smallest)
}

test min {
  assert(min([]) == None)
  assert(min([1]) == Some(1))
  assert(min([1, 0, 2]) == Some(0))
}

fun render_link(src: String): String {
  assert(src.starts_with("["))

  match src.index_of("]") {
    Some(i) => {
      let link_text = src.substring(1, i)
      let link_url = src.substring(i + 2, src.len() - 1)
      "<a href=\"" ^ link_url ^ "\">" ^ render_inline_backticks(link_text) ^ "</a>"
    }
    None => src
  }
}

fun render_image(src: String): String {
  assert(src.starts_with("!["))

  match src.index_of("]") {
    Some(i) => {
      let image_descr = src.substring(2, i)
      let image_url = src.substring(i + 2, src.len() - 1)
      "<img src=\"" ^ image_url ^ "\" alt=\"" ^ image_descr ^ "\" />"
    }
    None => src
  }
}

fun render_inline_code(src: String): String {
  let inner = src.strip_prefix("`").strip_suffix("`")
  "<code>" ^ escape_angle_brackets(inner) ^ "</code>"
}

fun render_strong(src: String): String {
  let inner = src.strip_prefix("**").strip_suffix("**")
  "<strong>" ^ escape_angle_brackets(inner) ^ "</strong>"
}

fun render_emphasis(src: String): String {
  let inner = src.strip_prefix("*").strip_suffix("*")
  "<em>" ^ escape_angle_brackets(inner) ^ "</em>"
}

fun render_markdown_paragraph(src: String): String {
  "<p>" ^ render_inline(src) ^ "</p>"
}

fun render_markdown_bullets(items: List<String>): String {
  let rendered_items = items.map(fun(item: String) {
    let rendered_item = render_inline(item.strip_prefix("*").trim_left())
    "<li>" ^ rendered_item ^ "</li>"
  })

  "<ul>\n" ^ "\n".join(rendered_items) ^ "\n</ul>"
}

public fun render_markdown(src: String): String {
  let html_parts: List<String> = []

  for part in parse_markdown(src) {
    match part {
      Heading(heading) => {
        html_parts = html_parts.append(render_markdown_header(heading))
      }
      Paragraph(paragraph) => {
        html_parts = html_parts.append(render_markdown_paragraph(paragraph))
      }
      CodeBlock(code) => {
        html_parts = html_parts.append(render_markdown_code(code))
      }
      Bullets(items) => {
        html_parts = html_parts.append(render_markdown_bullets(items))
      }
      ThematicBreak => {
        html_parts = html_parts.append("<hr />")
      }
    }
  }

  "\n".join(html_parts)
}

test render_markdown_paragraph_newlines {
  assert(render_markdown("foo\nbar") == "<p>foo\nbar</p>")
}

test render_headers {
  assert(render_markdown("# foo") == "<h1>foo</h1>")
  assert(render_markdown("#  foo ") == "<h1>foo</h1>")

  assert(render_markdown("## foo") == "<h2>foo</h2>")
  assert(render_markdown("###### foo") == "<h6>foo</h6>")

  assert(render_markdown("#foo") == "<p>#foo</p>")
  assert(render_markdown("####### foo") == "<p>####### foo</p>")
}

test render_markdown_paragraph {
  assert(render_markdown("foo bar") == "<p>foo bar</p>")
}

test render_markdown_paragraph_escape_angle_brackets {
  assert(render_markdown("foo bar<") == "<p>foo bar&lt;</p>")
}

test render_markdown_paragraph_after_heading {
  assert(render_markdown("# foo\n\nbar") == "<h1>foo</h1>\n<p>bar</p>")
}

test render_backtick {
  assert(render_markdown("`foo`") == "<p><code>foo</code></p>")
}

test render_backtick_escape_angle_brackets {
  assert(render_markdown("`foo<`") == "<p><code>foo&lt;</code></p>")
}

test render_backtick_angle_brackets {
  assert(render_markdown("`List<T>`") == "<p><code>List&lt;T&gt;</code></p>")
}

test render_strong_escape_angle_brackets {
  assert(render_markdown("*foo<*") == "<p><em>foo&lt;</em></p>")
}

test render_backtick_in_heading {
  assert(render_markdown("# `foo`") == "<h1><code>foo</code></h1>")
}

test render_link {
  assert(render_markdown("[foo](example.com)") == "<p><a href=\"example.com\">foo</a></p>")
}

test render_malformed_link {
  assert(render_markdown("foo ) [ bar") == "<p>foo ) [ bar</p>")
}

test render_backtick_in_link {
  assert(render_markdown("[`foo` bar](#)") == "<p><a href=\"#\"><code>foo</code> bar</a></p>")
}

test render_link_with_parentheses {
  assert(render_markdown("[foo (bar)](baz.html)") == "<p><a href=\"baz.html\">foo (bar)</a></p>")
}

test render_triple_backtick {
  assert(render_markdown("```nocheck\nfoo\nbar\n```") == "<pre><code>foo\nbar</code></pre>")
}

test render_triple_backtick_escape_html {
  assert(render_markdown("```nocheck\nfoo <bar>\n```") == "<pre><code>foo &lt;bar&gt;</code></pre>")
}

test render_triple_backtick_blank_line {
  assert(render_markdown("```nocheck\nfoo\n\nbar\n```") == "<pre><code>foo\n\nbar</code></pre>")
}

test render_triple_backtick_keyword {
  assert(render_markdown("```garden nocheck\nfun foo\n```") == "<pre><code><a class=\"keyword\" href=\"/keyword:fun.html\">fun</a> foo</code></pre>")
}

test render_triple_backtick_comment {
  assert(render_markdown("```garden nocheck\nfoo // bar\n```") == "<pre><code>foo <span class=\"comment\">// bar</span></code></pre>")
}

test render_asterisk_bullet {
  assert(render_markdown("* foo\n* bar") == "<ul>
<li>foo</li>
<li>bar</li>
</ul>")
}

test render_asterisk_bullet_with_content_after {
  assert(render_markdown("* foo\n\nbar") == "<ul>
<li>foo</li>
</ul>
<p>bar</p>")
}

test render_asterisk_emphasis {
  assert(render_markdown("*foo*") == "<p><em>foo</em></p>")
}

test render_asterisk_strong {
  assert(render_markdown("**foo**") == "<p><strong>foo</strong></p>")
}

test render_thematic_break {
  assert(render_markdown("***") == "<hr />")
  assert(render_markdown("---") == "<hr />")
  assert(render_markdown("___") == "<hr />")
}

test render_html {
  assert(render_markdown("<script></script>") == "<p><script></script></p>")
}

test render_html_comment {
  assert(render_markdown("<!-- foo -->") == "<p><!-- foo --></p>")
}

test render_image {
  assert(render_markdown("![foo](/url)") == "<p><img src=\"/url\" alt=\"foo\" /></p>")
}

fun looks_like_type(name: String): Bool {
  let upper_letters = "ABCDEFGHIJKLMNOPQRSTUVWXYZ".chars()
  upper_letters.contains(name.substring(0, 1))
}

test looks_like_type {
  assert(looks_like_type("Abc"))

  assert(looks_like_type("abc").not())
}
