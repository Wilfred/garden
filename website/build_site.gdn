import "__fs.gdn" as fs
import "__random.gdn" as random
import "__reflect.gdn" as reflect
import "__time.gdn" as time
import "__prelude.gdn" as prelude
import "./markdown.gdn"
import "./log.gdn" as log

/// A list of all the files in `website_dir` that have a .md extension.
fun markdown_files(website_dir: Path): List<Path> {
  let dir_files = fs::list_directory(website_dir).or_throw()
  dir_files.filter(fun(p: Path) { p.extension() == Some("md") })
}

/// Given a snippet of source code `src`, remove all the leading lines
/// that are just comments.
fun drop_leading_comments(src: String): String {
  let lines = src.lines()

  let first_code_line = 0
  for (i, line) in lines.enumerate() {
    if line.starts_with("//") {
      continue
    }
    if line == "" {
      continue
    }

    first_code_line = i
    break
  }

  "\n".join(lines.slice(first_code_line, lines.len()))
}

fun write_fun_page(ns_name: String, ns: Namespace, fun_name: String, out_dir: Path, base_tmpl_src: String): Unit {
  let qualified_name = "::".join([ns_name, fun_name])

  match reflect::doc_comment(ns, fun_name) {
    Some(doc_comment) => {
      let heading = if ns_name == "__prelude.gdn" {
        "".join(["# `", fun_name, "()`"])
      } else {
        "".join(["# `", qualified_name, "()`"])
      }

      let src = reflect::source_for_fun(ns, fun_name)
      let page_src = render_doc_comment(heading, doc_comment, src, None)

      let dest_path = out_dir.join("fun:" ^ qualified_name ^ ".html")
      write_website_page(base_tmpl_src, page_src, dest_path, Some(fun_name))
    }
    None => {
      let parts = [
        "Tried to generate a page for ",
        qualified_name,
        " but it doesn't have a doc comment."]
      log::warn("".join(parts))
    }
  }
}

fun write_method_page(type_name: String, method_name: String, out_dir: Path, base_tmpl_src: String): Unit {
  let qualified_name = type_name ^ "::" ^ method_name

  match reflect::doc_comment_for_method(type_name, method_name) {
    Some(doc_comment) => {
      let heading = "# `" ^ qualified_name ^ "()`"

      let page_src = render_doc_comment(
        heading,
        doc_comment,
        reflect::source_for_method(type_name, method_name),
        None)

      let dest_path = out_dir.join("method:" ^ qualified_name ^ ".html")
      write_website_page(base_tmpl_src, page_src, dest_path, Some(qualified_name))
    }
    None => {
      log::warn("Tried to generate a page for method " ^ qualified_name ^ " but it doesn't have a doc comment.")
    }
  }
}

/// Render `doc_comment` as HTML.
fun render_doc_comment(heading: String, doc_comment: String, src: Option<String>, file: Option<Path>): String {
  let src = match src {
    Some(src) => {
      "```title:\"Source Code\"\n" ^ drop_leading_comments(src) ^ "\n```"
    }
    None => ""
  }

  doc_comment = doc_comment.replace("\n\n```\n", "\n\n```title:Example\n")

  let md_src = "".join([heading, "\n\n" , doc_comment, "\n\n", src])
  render_markdown(md_src, file)
}

fun render_type_doc_comment(heading: String, doc_comment: String, src: String, methods: List<String>, type_name: String): String {
  let src = "```title:\"Source Code\"\n" ^ drop_leading_comments(src) ^ "\n```"

  let methods_section = if methods.is_empty() {
    ""
  } else {
    let method_list = methods.map(fun(m: String) {
      "* [`" ^ m ^ "()`](/method:" ^ type_name ^ "::" ^ m ^ ".html)"
    })
    "\n\n## Methods\n\n" ^ "\n".join(method_list)
  }

  let md_src = "".join([heading, "\n\n" , doc_comment, "\n\n", src, methods_section])
  render_markdown(md_src, None)
}

/// Look up the doc comment for `type_name`, render it to HTML and
/// write it to `out_dir`.
fun write_type_page(type_name: String, out_dir: Path, base_tmpl_src: String): Unit {
  match reflect::doc_comment_for_type(type_name) {
    Some(doc_comment) => {
      let heading = "".join(["# `", type_name, "` type"])
      let methods = reflect::methods_for_type(type_name)

      let type_src = match reflect::source_for_type(type_name) {
        Some(src) => src
        None => {
          log::warn("No source found for built-in type " ^ type_name)
          ""
        }
      }

      let page_src = render_type_doc_comment(heading, doc_comment, type_src, methods, type_name)

      let dest_path = out_dir.join("type:" ^ type_name ^ ".html")
      write_website_page(base_tmpl_src, page_src, dest_path, Some(type_name))
    }
    None => {
      log::warn("No doc comment found for built-in type " ^ type_name)
    }
  }
}

fun write_markdown_page(
  website_dir: Path,
  out_dir: Path,
  base_tmpl_string: String,
  md_path: Path,
  title: Option<String>
): Unit {
  let page_file_name = md_path.file_name().or_throw()
  let out_path = out_dir.join(page_file_name).set_extension("html")

  let page_src_md = md_path.read().or_throw()
  let page_src = render_markdown(substitute_shorthand(website_dir, page_src_md), Some(md_path))
  write_website_page(base_tmpl_string, page_src, out_path, title)
}

struct BlogPost {
  published: Bool,
  title: Option<String>,
  date: Option<String>,
  src: String,
  path: Path,
}

fun split_metadata(src: String): (Option<String>, String) {
  let metadata_start = "```metadata\n"
  let metadata_end = "\n```\n"

  if src.starts_with(metadata_start).not() {
    return (None, src)
  }

  match src.index_of(metadata_end) {
    Some(i) => {
      let before = src.substring(0, i)
      let after = src.substring(i + metadata_end.len(), src.len())
      (Some(before.strip_prefix(metadata_start)), after)
    }
    None => {
      (None, src)
    }
  }
}

test split_metadata {
  assert(split_metadata("```metadata\nfoo\n```\nstuff\n") == (Some("foo"), "stuff\n"))
}

fun blog_posts(website_dir: Path): List<BlogPost> {
  let posts: List<BlogPost> = []

  let blog_post_dir = website_dir.join("blog")
  for path in fs::list_directory(blog_post_dir).or_throw() {
    if path.extension() != Some("md") {
      continue
    }

    let published = False
    let title: Option<String> = None
    let date: Option<String> = None
    let src = match path.read() {
      Ok(src) => {
        let (metadata, src) = split_metadata(src)
        for line in metadata.or_value("").lines() {
          if line == "published: true" {
            published = True
          } else if line.starts_with("title: ") {
            title = Some(line.strip_prefix("title: "))
          } else if line.starts_with("date: ") {
            date = Some(line.strip_prefix("date: "))
          }
        }

        src
      }
      Err(e) => {
        log::warn("Could not read path: " ^ path.p ^ " error: " ^ e)
        continue
      }
    }

    posts = posts.append(BlogPost{ path: path, src: src, published: published, title: title, date: date })
  }

  posts
}

fun build_blog(website_dir: Path, out_dir: Path, base_tmpl_src: String): Unit {
  for post in blog_posts(website_dir) {
    if post.published.not() {
      continue
    }

    let src = post.src

    match post.date {
      Some(date) => {
        src = "*" ^ date ^ "*\n\n" ^ src
      }
      None => {}
    }

    match post.title {
      Some(title) => {
        src = "# " ^ title ^ "\n" ^ src
      }
      None => {}
    }

    let post_file_name = post.path.file_name().or_throw()
    let out_path = out_dir.join("blog").join(post_file_name).set_extension("html")

    let html = render_markdown(substitute_shorthand(website_dir, src), Some(post.path))
    write_website_page(base_tmpl_src, html, out_path, post.title)
  }
}

/// Build the entire garden website.
fun build_site(): Unit {
  let website_dir = source_dir_path().parent().or_throw().parent().or_throw().join("website")
  fs::set_working_directory(website_dir).or_throw()

  let out_dir = website_dir.join("dist")

  // Create necessary directories
  fs::create_dir(out_dir)
  fs::create_dir(out_dir.join("blog"))
  fs::create_dir(out_dir.join("static"))
  fs::create_dir(out_dir.join("static").join("fonts"))

  let base_tmpl_path = website_dir.join("template.html")
  let base_tmpl_src = base_tmpl_path.read().or_throw()

  build_blog(website_dir, out_dir, base_tmpl_src)

  let seen_keyword_pages: List<String> = []
  let seen_operator_pages: List<String> = []

  for md_path in markdown_files(website_dir) {
    let file_name = match md_path.file_name() {
      Some(n) => n,
      None => continue,
    }

    let title: Option<String> = None
    match file_name.split_once(":") {
      Some((before, after)) => {
        if before == "keyword" {
          let keyword = after.strip_suffix(".md")
          seen_keyword_pages = seen_keyword_pages.append(keyword)
          title = Some(keyword)
        } else if before == "operator" {
          let keyword = after.strip_suffix(".md")
          seen_operator_pages = seen_operator_pages.append(keyword)
          title = Some(keyword)
        }
      }
      None => {}
    }

    write_markdown_page(website_dir, out_dir, base_tmpl_src, md_path, title)
  }

  for keyword in reflect::keywords() {
    if seen_keyword_pages.contains(keyword).not() {
      log::warn("Expected a page documenting keyword: " ^ keyword)
    }
  }

  for operator in reflect::operators() {
    let page_name = if operator == "/" { "slash" } else { operator }
    if seen_operator_pages.contains(page_name).not() {
      log::warn("Expected a page documenting operator: " ^ operator)
    }
  }

  for type_name in reflect::prelude_types() {
    // We have a manually created type::Tuple.md file, so don't look
    // for a doc comment in that case.
    if website_dir.join("type:" ^ type_name ^ ".md").exists().not() {
      write_type_page(type_name, out_dir, base_tmpl_src)
    }

    for method_name in reflect::methods_for_type(type_name) {
      write_method_page(type_name, method_name, out_dir, base_tmpl_src)
    }
  }

  let namespaces = [
    ("__prelude.gdn", prelude),
    ("__fs.gdn", fs),
    ("__random.gdn", random),
    ("__reflect.gdn", reflect),
    ("__time.gdn", time),
  ]

  // Validate that all built-in files are documented
  let documented_files: List<String> = []
  for (ns_name, _ns) in namespaces {
    documented_files = documented_files.append(ns_name)
  }
  for built_in_file in reflect::built_in_files() {
    if documented_files.contains(built_in_file).not() {
      log::warn("Builtin file " ^ built_in_file ^ " is not documented in the namespaces list")
    }
  }

  for (ns_name, ns) in namespaces {
    for fun_name in reflect::namespace_functions(ns) {
      write_fun_page(ns_name, ns, fun_name, out_dir, base_tmpl_src)
    }
  }

  // Copy static files (PNG, MP4, fonts)
  for path in fs::list_directory(website_dir).or_throw() {
    let ext = path.extension()
    if (ext == Some("png")) || (ext == Some("mp4")) {
      let file_name = path.file_name().or_throw()
      let dest = out_dir.join(file_name)
      fs::copy_file(path, dest).or_throw()
    }
  }

  // Copy font files
  let fonts_src_dir = website_dir.join("static").join("fonts")
  let fonts_dest_dir = out_dir.join("static").join("fonts")
  for path in fs::list_directory(fonts_src_dir).or_throw() {
    if path.extension() == Some("woff2") {
      let file_name = path.file_name().or_throw()
      let dest = fonts_dest_dir.join(file_name)
      fs::copy_file(path, dest).or_throw()
    }
  }
}

/// Convert `["a", "b", "c"]` to `"a, b and c"`.
fun join_with_commas_and(items: List<String>): String {
  let last_item = match items.last() {
    Some(item) => item,
    None => return "",
  }

  let but_last = items.slice(0, -1)
  if but_last.is_empty() {
    return last_item
  }

  " and ".join([", ".join(but_last), last_item ^ "."])
}

/// Helper function to create markdown links of the form
//
/// ```text
/// [`foo`](bar.html)
/// ```
fun code_link(text: String, url: String): String {
  "[`" ^ text ^ "`](" ^ url ^ ")"
}

/// Replace all __FOO strings in markdown `src` with runtime values.
fun substitute_shorthand(website_dir: Path, src: String): String {
  let keyword_links = reflect::keywords().map(fun(keyword: String) {
    code_link(keyword, "./keyword:" ^ keyword ^ ".html")
  })

  let keyword_links = join_with_commas_and(keyword_links)

  let operator_links = reflect::operators().map(fun(operator: String) {
    let page_name = if operator == "/" { "slash" } else { operator }
    code_link(operator, "./operator:" ^ page_name ^ ".html")
  })

  let operator_links = join_with_commas_and(operator_links)

  let type_links = reflect::prelude_types().map(fun(name: String) {
    code_link(name, "./type:" ^ name ^ ".html")
  })

  let type_links = join_with_commas_and(type_links)

  let prelude_funs = reflect::namespace_functions(prelude).map(fun(name: String) {
    code_link(name ^ "()", "./fun:__prelude.gdn::" ^ name ^ ".html")
  })
  let prelude_funs = join_with_commas_and(prelude_funs)

  let fs_funs = reflect::namespace_functions(fs).map(fun(name: String) {
    code_link(name ^ "()", "./fun:__fs.gdn::" ^ name ^ ".html")
  })
  let fs_funs = join_with_commas_and(fs_funs)

  let random_funs = reflect::namespace_functions(random).map(fun(name: String) {
    code_link(name ^ "()", "./fun:__random.gdn::" ^ name ^ ".html")
  })
  let random_funs = join_with_commas_and(random_funs)

  let reflect_funs = reflect::namespace_functions(reflect).map(fun(name: String) {
    code_link(name ^ "()", "./fun:__reflect.gdn::" ^ name ^ ".html")
  })
  let reflect_funs = join_with_commas_and(reflect_funs)

  let time_funs = reflect::namespace_functions(time).map(fun(name: String) {
    code_link(name ^ "()", "./fun:__time.gdn::" ^ name ^ ".html")
  })
  let time_funs = join_with_commas_and(time_funs)

  let blog_links: List<String> = []
  for post in blog_posts(website_dir) {
    if post.published.not() {
      continue
    }

    let html_path = post.path.set_extension("html")
    let file_name = match html_path.file_name() {
      Some(fn) => fn
      None => continue
    }

    let link_text = match post.title {
      Some(title) => title
      None => file_name
    }

    let link_with_date = match post.date {
      Some(date) => link_text ^ " (" ^ date ^ ")"
      None => link_text
    }

    let link = "* [" ^ link_with_date ^ "](blog/" ^ file_name ^ ")"
    blog_links = blog_links.append(link)
  }

  let blog_links = "\n".join(blog_links)

  src
    .replace("__KEYWORDS", keyword_links)
    .replace("__OPERATORS", operator_links)
    .replace("__BUILT_IN_TYPES", type_links)
    .replace("__PRELUDE_FUNS", prelude_funs)
    .replace("__FS_FUNS", fs_funs)
    .replace("__RANDOM_FUNS", random_funs)
    .replace("__REFLECT_FUNS", reflect_funs)
    .replace("__TIME_FUNS", time_funs)
    .replace("__BLOG_LINKS", blog_links)
}

/// Wrap `page_src` in the base template and write to the file `dest_path`.
fun write_website_page(
  base_tmpl_src: String,
  page_src: String,
  dest_path: Path,
  title: Option<String>
): Unit {
  let title = match title {
    Some(s) => s ^ " - Garden"
    None => "Garden"
  }

  let base_tmpl_src = base_tmpl_src.replace("__TITLE", title)

  let (header, footer) = match base_tmpl_src.split_once("__MAIN_CONTENT") {
    Some(s) => s,
    None => ("", "")
  }

  let src = "".join([header.trim_right(), page_src, footer.trim_left()])
  fs::write_file(src, dest_path).or_throw()
}

{
  build_site()
}

fun source_dir_path(): Path {
  source_directory().or_throw()
}
